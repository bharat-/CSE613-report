\section{Background}
\label{bg}

%Background...
%
%Typical length: 0 pages to 1.0.
%
%Background and Related Work can be similar.  Most citations will be
%in this section.
%
%1. Describe past work and criticize it, fairly.  Use citations to
%JUSTIFY your criticism!  Problem: hard to compare to YOUR work, b/c
%you've not yet described your work in enough detail.  Solution: move
%this text to Related Work at end of paper.
%
%2. Describe in some detail, background material necessary to
%understand the rest of the paper.  Doesn't happen often, esp. if
%you've covered it in Intro.
%
%Example, submit a paper to a storage conference: reviewers are
%experts in storage.  Don't need to tell them about basic disk
%operation.  But if your paper, say, is an improvement over an
%already-advanced data structure (eg., COLA), then it'd make sense to
%describe basic COLA algorithms in some detail.
%
%Important: open the bg section with some "intro" text to tell reader
%what to expect (so experienced readers can skip it).
%
%If your bg material is too short, can fold it into opening of
%'design' section.


Breadth First Search, also knows as BFS, is an algorithm for traversing
or searching tree or graph data structure. The algorithm finds shortest paths
from a given source node to all other nodes, in
terms of the number of edges in the path. It starts at the source node and
explores the neighbour nodes first before moving to the next level neighbours.
Its a well known research topic. A variety of parallel BFS algorithms trying to
improve complexity, parallelism, distributed cache and io performance have been
proposed till date.\newline
%Some of these parallel algorithms are \emph{work
%efficient}, meaning that the total number of operations performed is the same
%to within a constant factor as that of a comparable serial algorithm.
A recent paper proposed Hybrid++ BFS algorithm for an accelerated processing
unit (APU), a heterogeneous processor which fuses the CPU and GPU cores on a
single die [1]. Hybrid++ leverages the strength of CPUs and GPUs for serial and
data-parallel execution, respectively, to carefully partition BFS by selecting
the appropriate execution-core and graph-traversal direction for every search
iteration.\newline
Current cluster implementations suffer from high latency data communication
with large volumes of transfers across nodes, leading to inefficiency in
performance and energy consumption. \emph{Large Scale Energy-Efficient Graph
Traversal: A Path to Efficient Data-Intensive Supercomputing} [4] tried to
overcome these constraints using a combination of efficient low-overhead data
compression techniques to reduce transfer volumes along with latency-hiding
techniques.\newline
Pertaining to NUMA architecture, \emph{NUMA-optimized Parallel Breadth-first
Search on Multi-core Single-node System} [5] proposed a non-uniform memory
access (NUMA)-optimized BFS, that reduced memory accesses to remote RAM on a
NUMA architecture system. \emph{Fast and Energy-efficient Breadth-First Search
on a Single NUMA System} [6] further investigated the computational
complexity of the bottom-up, a major bottleneck in NUMA-optimized BFS.\newline
\emph{Performance evaluation of breadth-first search on Intel Xeon Phi} [7],
evaluates BFS performance evaluation on a recently released high-performance
Intel Xeon Phi coprocessor. They examine the previously proposed Queue-based
and Read-based approaches to BFS implementation. They also apply several
optimization techniques, such as manual loop unrolling and prefetching, that
significantly improve performance on Intel Xeon Phi. On a representative graph
set, Intel Xeon Phi 7120P demonstrates 78\% maximum and 37\% average speedup as
compared to the Intel Xeon E5-2660 processor.


Very few have worked to optimize energy/power efficiency of BFS algorithm.
Considering the recent trends in application of graph algorithms in big data
and information analysis, energy efficiency is a major concern.

In this project we have analysed some of the existing parallel BFS algorithms
in terms of energy efficiency.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% For Emacs:
% Local variables:
% fill-column: 70
% End:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% For Vim:
% vim:textwidth=70
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LocalWords:
